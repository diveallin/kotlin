### 고차함수
- 함수를 파라미터로 받거나 함수를 리턴하는 함수
- ex) lock(), map()

```kotlin
fun <T> lock(lock: Lock, body: () -> T): T { 
  lock.lock()
    try {
      return body()
    }
    finally {
      lock.unlock() 
    }
}
val result = lock(lock) { // 마지막 인자가 함수이면 괄호 밖에서 처리 가능)
  ...
}
// lock object로 lock을 걸고 body()를 실행 후 리턴
```

```kotlin
fun <T, R> List<T>.map(transform: (T) -> R): List<R> { 
  val result = arrayListOf<R>()
  for (item in this)
    result.add(transform(item)) 
  return result
}
val doubled = arrayListOf(1, 2, 3).map { value -> value * 2 } // 호출 인자가 람다만 있다면 괄호를 완전 생략
val doubled2 = arrayListOf(1, 2, 3).map { it * 2 } // it은 단일 파라미터의 경우 암묵적 이름이다. "->" 생략가능
```

- 람다의 파라미터를 사용하지 않는 다면 "_" 로 대체
```kotlin
map.forEach {_, value -> println("$value") }
```

### 람다식
- 중괄호로 감싼다
- 파라미터는 중괄호 안에 위치, 선택적으로 타입을 표시
- 몸체는 "->" 부호 뒤에 온다.

```kotlin
val sum = { x: Int, y: Int -> x + y }
// 축약
val sum: (Int, Int) -> Int = { x, y -> x+ y }
```

- 추정한 리턴 타입이 Unit이 아니면 몸체의 마지막 식을 리턴 값으로 처리
- 파라미터가 한 개면 it으로 암묵적으로 선언
- 한정한 리턴 표현으로 명식적으로 리턴할 수 있다.

```kotlin
// 아래 식은 동일하다
ints.filter {
  val filtered = it > 0
  filtered
}
ints.filter {
  val filtered = it > 0
  return@filter filtered
}
```

### 익명함수
- 일반 함수에서 이름이 없는 경우
- 단일 식인 경우 몸체를 "=" 이후 표현하거나 블록으로 구현
- 블록 몸체를 가진 익명 함수의 경우 명시적으로 리턴 타입을 지정해야 한다.
- *__람다식의 리턴은 둘러싼 함수를 리턴하나 익명함수에서의 리턴은 익명함수를 리턴한다.__*

```kotlin
fun(x: Int, y: Int): Int {
  return x+ y
}
// 위 식은 아래 식으로 표현 가능
fun(x: Int, y: Int) = x + y
```

- 함수 파라미터로 함수를 전달하는 경우 사용될 수 있다.
  - 파라미터 타입을 유추할 수 있다면 생략 가능
  - 몸체가 식인 익명 함수에 대한 리턴 타입은 자동으로 유추
  - 익명함수 파라미터는 항상 괄호안에 전달해야 함. 괄호 밖에서 블럭처리는 람다 식에 대해서만 가능
```kotlin
ints.filter(fun(item) = item > 0)
```

### 클로저
- 람다식과 익명함수는 외부범위에 선언된 변수에 접근할 수 있다. 자바와 달리 클로저에 캡쳐한 변수를 수정할 수 있다.
```kotlin
var sum = 0
ints.filter { it > 0 }.forEach {
  sum += it
}
println(sum)
```
